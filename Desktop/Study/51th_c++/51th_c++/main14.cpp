#include<iostream>

// 동적할당
//	- 런타임 중에 실시간으로 필요한 메모리를 할당 받거나 해제하는 작업
//	- 힙 영역


// 전역변수 - 데이터영역에 저장됨
//  데이터 영역
// 프로그램 실행 시 
// 프로그램 종료 시

// 프로그램 실행 중에 데이터 영역의 크기를 변동시킬 수 없음
// 이미 할당과 해제량이 저행진 채로 프로그램이 빌드되어 있음
// 배열의 크기를 변수로 만든다는 것은 이러한 동작원리를 전부 무시하는 행위
int g_arr[100] = {};


int main()
{
	// 지역변수 - 스택영역에 저장됨
	// 1. 배열의 크기를 확정짓지 않는 경우(불가능, 초기 데이터를 입력하면 그 개수만큼의 배열로 인식)
	// int arr[] = {1,2,3};

	int arraySize = 100;

	// 배열의 크기를 변수로 지정하는 경우
	// 런타임(프로그램 실행 중) 에 배열의 크기가 확정이 됨, 배열이 선언된 메모리 영역의 크기를 계산할 수 없다는 뜻
	//  각 함수의 호출 시 할당할 스택의 크기를 확정지을 수 없음
//	int arr2[arraySize] = { 1, 2, 3 };  // 넣는 값은 실제로는 변수이기 때문에 오류가 뜸
	int arr[3] = {1, 2, 3};


	//  그래서 동적할당 이 필요함
	//	- 런타임 중에 실시간으로 필요한 메모리를 할당 받거나 해제하는 작업
	//	- 힙 영역

	// 메모리 할당 함수
	// 100바이트를 힙 영역에 할당함
	 
	// 이전 수업에서는 이미 특정 자료형(용도)로 만들어진 공간을 그 자료형에 맞는 포인터로 
	// 가르켜서 원래 목적대로 사용(접근) 했다면
	// 동적할당(malloc 함수)이 할당받은 공간은 용도가 정해지지 않은 빈 공터라고 생각 할 수 있다.
	// 따라서 할당받은 곳의 주소값만 알고 있으면, 내가 원하는 포인터로 해당 주소를 받아서
	// 그 공간을 원하는 단위(자료형)으로 접근 및 데이터 쓰기, 읽기가 가능하다.

	// malloc 함수는 그래서 반환타입이 void* 타입이다(특정 자료형으로 해석될 여지를 주지 않고
	//메모리를 할당 받은 프로그래머가 그곳의 사용 용도를 결정하게 하기 위해서)
	//	void* pData = malloc(100);
	int* pInt = (int*)malloc(100);
	pInt[0] = 100;
	pInt[1] = 200;
	pInt[24] = 2500; // 100을 int값인 4바이트로 나눈 25칸까지만 가능
	pInt[25] = 200;  // 할당받은 100 바이트 공간을 초과하는 상황, 하지만 컴파일 오류는 발생하지 않음 문법적인 오류는 없기 때문
					// 하지만 런타임 오류에서 적발 될 때도, 아닐때도 있어서 무서운것임
					// 
	// 지정된 영역을 초과해서 메모리에 데이터를 기록 -> 데이터 해제
	// 힙 손상(Heap corruption) 발생
	// 할당 받은 공간을 초과하는 일이 발생 하지 않도록 각별히 주의해야함.
	// 힙 손상 오류는 발생 시 굉장한 시간이 소요 될 수 있음.

	free(pInt); // 이렇게 하면 오류를 볼 수 있음 

	// 함수 스택(지역 변수),  데이터 역역(전역 변수) 모두 프로그래머가 직접 메모리를 해제할 필요가 없음.
	// 힙 영역(동적 할당) - 프로그램 실행 도중에 얼마든지 할당 받을 수 있는 영역, 
	// 대신 프로그래머가 반드시 프로그램 종료 시 메모리를 해제시켜야함
	// 동적 할당 받은 공간을 해제시키지 않으면, 그 메모리 영역이 사용중인 상태로 남게 됨(메모리 누수(leak))
	// 메모리 누수가 심각하게 누적되면 시스템 메모리 부족 현상으로 재부팅을 해주어야 함.


	return 0;
}